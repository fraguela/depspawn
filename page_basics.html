<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DepSpawn: How to write a DepSpawn application</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DepSpawn
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_basics.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How to write a DepSpawn application </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec_semantics">Semantics</a><ul><li class="level2"><a href="#sec_functions">Write your parallel tasks as functions</a></li>
<li class="level2"><a href="#sec_dependencies">Express dependencies by means of the parameter types</a></li>
<li class="level2"><a href="#sec_semanticsdetails">The fine print</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_api">Interface</a><ul><li class="level2"><a href="#sec_example1">Example</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="sec_semantics"></a>
Semantics</h1>
<p>DepSpawn has a simple API and semantics for the parallelization of applications using tasks that the library automatically executes when their data dependencies have been fulfilled. Both of them are briefly described in this page. A more detailed discussion can be found in the publication <a href="http://www.des.udc.es/~basilio/papers/Gonzalez13-DepSpawn.pdf">A framework for argument-based task synchronization with automatic detection of dependencies</a> (<a href="http://dx.doi.org/10.1016/j.parco.2013.04.012">DOI 10.1016/j.parco.2013.04.012</a>), which only lacks some of the new synchronization mechanisms added in version 2.0 and described in <a class="el" href="page_basics.html#sec_api">Interface</a>.</p>
<h2><a class="anchor" id="sec_functions"></a>
Write your parallel tasks as functions</h2>
<p>A first thing to take into account is that all the parallel tasks must be expressed as functions and they must communicate with the rest of the application only by means of their arguments. This means that these functions should have return type <code>void</code> (if this is not the case, DepSpawn is going to ignore the value returned, anyway!) and provide their outputs by means of their arguments. All the kinds of C++ functions are supported:</p><ul>
<li>Regular C++ functions (e.g. <code>void myf(int i, std::vector&lt;char&gt;&amp; x) {...}</code>)</li>
<li>Member functions (those that belong to a <code>struct</code> or <code>class</code>)</li>
<li>Lambda functions (e.g. <code>[](Widget &amp;r, double f, const char *str) {...}</code>)</li>
<li>Functor objects (those that define <code>operator()</code>)</li>
<li><code>std::function</code> objects, defined in the standard header file <code>&lt;functional&gt;</code></li>
<li><code>boost::function</code> objects, defined in the Boost.Function library header file <code>&lt;boost/function.hpp&gt;</code></li>
</ul>
<h2><a class="anchor" id="sec_dependencies"></a>
Express dependencies by means of the parameter types</h2>
<p>DepSpawn analyzes the types of the formal parameters of a function to identify whether they can be only read, or also modified, by the function. This, together with the actual arguments provided to the function when it is launched to execution, defines the data dependencies of the associated parallel task. Three situations are distinguished regarding the type of the formal parameters:</p><ul>
<li>In C++ arguments can be passed by value or by reference. The changes made to the arguments passed by value can only be seen inside the function, as in fact they are copies of the original objects provided in the invocation. As a result these arguments are only inputs, and never outputs of the function.</li>
<li>Arguments passed by reference allow a function to access the original objects provided by the caller instead of copies. C++ references can be annotated as <code>const</code> or not.<ul>
<li><code>const</code> references do not allow to modify the object received, so just as the arguments passed by value, they are only inputs to the function. <dl class="section warning"><dt>Warning</dt><dd>Programmers can circunvent this semantics and actually modify these arguments in their functions, for example by writing to <code>mutable</code> portions of the object or changing their type by means of <code>const_cast</code>. Since DepSpawn assumes that <code>const</code> references are not modified inside a function, in these situations it would be better to turn such parameters into non-<code>const</code> references so that it knows the truth about your evil intentions.</dd></dl>
</li>
<li>non-<code>const</code> references can be both read and modified by the function, which turns them into inputs and outputs, being thus the natural mechanism to return results in DepSpawn.</li>
</ul>
</li>
</ul>
<p>It is very important to remember that DepSpawn only tracks the dependencies on the arguments provided to the tasks, and not on any other piece of data. This means that in the code </p><div class="fragment"><div class="line"><span class="keyword">struct </span>example_struct {</div><div class="line">  <span class="keywordtype">float</span> value;</div><div class="line">  <span class="keywordtype">double</span> *array;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> my_function(<span class="keyword">const</span> example_struct &amp;arg1, <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> * <span class="keyword">const</span> p) {</div><div class="line">  arg1.array[n] = *p;</div><div class="line">  *p = arg1.array[n+1];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() </div><div class="line">{ example_struct my_struct;</div><div class="line">  <span class="keywordtype">double</span> *my_ptr;</div><div class="line">  <span class="keywordtype">int</span> i;</div><div class="line">  ...</div><div class="line">  <a class="code" href="namespacedepspawn.html#aad6ae0fb6423de998a3418ac3b52aef9">spawn</a>(my_function, my_struct, i, my_ptr);</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>DepSpawn will take into account for the dependencies of <code>my_function</code> the memory occupied by <code>my_struct</code>, <code>i</code> and <code>my_ptr</code>, which are its arguments, but not the memory locations pointed by <code>my_struct.array</code> and <code>ptr</code>, which have in fact an extent that is totally unknown to DepSpawn. That is, for every argument <code>x</code>, the runtime tracks the memory region [<code>&amp;x</code>, <code>&amp;x</code>+<code>sizeof(x)</code>). As a result, the two assignments inside <code>my_function</code> are untracked, and thus unsafe with respect to other parallel tasks that can access those memory positions.</p>
<h2><a class="anchor" id="sec_semanticsdetails"></a>
The fine print</h2>
<p>Once we have expressed which are the inputs and the outputs of our tasks, DepSpawn makes sure that</p><ul>
<li>Whenever a task has a read-only dependency on an argument, i.e., it is only an input to the task, the task is only scheduled for execution when all the preceding tasks that write to some memory position within that argument have finished.</li>
<li>When a task can write to an argument, i.e., it is a potential output for the task, the task is only scheduled for execution when all the preceding tasks that access some memory position within that argument, no matter it is for reading or for writing, have finished.</li>
</ul>
<p>When an application does not have subtasks, that is, when all the tasks are spawned only by the main thread of execution, it is clear that the preceding tasks are those that the main thread spawned before the one being considered. A program has subtasks when the tasks spawned by the main thread also spawn tasks themselves, which also means that several threads can be spawning tasks. In this more general situation, two questions must be answered:</p><ul>
<li>Which tasks should be considered as preceding tasks of a new one? As of now, DepSpawn considers as preceding tasks all the tasks spawned by any thread before the considered one.</li>
<li>When does a task with subtasks finish? As of now, DepSpawn considers that a task finishes only when all its subtasks finish.</li>
</ul>
<h1><a class="anchor" id="sec_api"></a>
Interface</h1>
<p>All the components of the library are made available in the header file <code><a class="el" href="depspawn_8h_source.html" title="Main header file, and only one that needs to be included in the client code. ">depspawn.h</a></code> and they are encapsulated in the <code><a class="el" href="namespacedepspawn.html" title="Public library API. ">depspawn</a></code> namespace. These are the main components:</p><ul>
<li>The most important function is of course <a class="el" href="namespacedepspawn.html#aad6ae0fb6423de998a3418ac3b52aef9" title="Spawns a std::function. ">spawn()</a>, which allows to request the parallel execution of any function <code>f</code> with any arbitrary list of arguments <code>a</code>, <code>b</code>, <code>c</code>, ... just with <code>spawn(f, a, b, c, ... )</code>.</li>
<li><code><a class="el" href="namespacedepspawn.html#a61d360457bcbd1f029f1689d36f9c2e1" title="Waits for all tasks to finish. ">wait_for_all()</a></code> is probably the next most important function. As its name implies, it waits for all the spawned tasks to finish.</li>
<li><code><a class="el" href="namespacedepspawn.html#aabdf2dde272f0a8d5157242141dbf5d6">wait_for_subtasks()</a></code> waits for all the subtasks spawned within the current task.</li>
<li><code><a class="el" href="namespacedepspawn.html#a8524349d8721f04673913fdf6b2d1554" title="Wait for a specific group of variables to be written. ">wait_for()</a></code> waits for the specific set of objects provided as arguments to be ready for reading.</li>
<li><code><a class="el" href="namespacedepspawn.html#a0567a4e61daab69185cbf9bf5a814d8e">set_threads()</a></code> is the preferred way to initialize the library, as it allows to specify both the number of threads to use and the stack size of each thread.</li>
<li><code><a class="el" href="namespacedepspawn.html#a465cc128e6abba52d4b99762c4a34cc7" title="Retrieve number of threads currently in use. ">get_num_threads()</a></code> retrieves the number of threads in use</li>
<li><code><a class="el" href="namespacedepspawn.html#a8906adda62ba1a66d511aced3960ea4e">set_task_queue_limit()</a></code> can help optimize the performance if DepSpawn has been compiled setting the configuration variable <code>DEPSPAWN_FAST_START</code> on (see <a class="el" href="page_installation.html">Installing DepSpawn</a>). When this variable is active, whenever a thread spawns a new task, it checks how many ready tasks (i.e., already free of dependencies) are waiting to be executed. If this value is greater than a given threshold, the thread tries to execute one of these pending tasks before returning to its current task. By default the library sets this threshold to twice the number of threads in use specified using <code><a class="el" href="namespacedepspawn.html#a0567a4e61daab69185cbf9bf5a814d8e">set_threads()</a></code>. The user however is free to modify this threshold using <code><a class="el" href="namespacedepspawn.html#a8906adda62ba1a66d511aced3960ea4e">set_task_queue_limit()</a></code>.</li>
<li><code><a class="el" href="namespacedepspawn.html#ae5d18154f4ad87e6819dd59f3df0b40f">get_task_queue_limit()</a></code> reports the task queue limit, as described above, or -1 if the library was compiled with <code>DEPSPAWN_FAST_START</code> off.</li>
<li>The <code><a class="el" href="classdepspawn_1_1_observer.html" title="When destroyed, it makes sure that all the tasks spawned by the current thread since its creation hav...">Observer</a></code> class provides objects which upon destruction wait for all the tasks spawned by their thread since their creation to finish. As a result, for example, the code<div class="fragment"><div class="line">{ <a class="code" href="classdepspawn_1_1_observer.html">depspawn::Observer</a> o;</div><div class="line">  <a class="code" href="namespacedepspawn.html#aad6ae0fb6423de998a3418ac3b52aef9">spawn</a>(f, a, b);</div><div class="line">  <a class="code" href="namespacedepspawn.html#aad6ae0fb6423de998a3418ac3b52aef9">spawn</a>(g, v[i], b);</div><div class="line">  <a class="code" href="namespacedepspawn.html#aad6ae0fb6423de998a3418ac3b52aef9">spawn</a>(h, a, q-&gt;value);</div><div class="line">}</div><div class="line">printf(...);</div></div><!-- fragment --> makes sure that the tasks <code>f</code>, <code>g</code> and <code>h</code> have finished before the <code>printf</code> statement.</li>
<li><code>depspawn_sync(...)</code> is a macro that executes the code between its parenthesis and waits for the tasks it has spawned to finish. It is therefore equivalent to<div class="fragment"><div class="line">{ <a class="code" href="classdepspawn_1_1_observer.html">depspawn::Observer</a> o; ... } </div></div><!-- fragment --></li>
<li><code><a class="el" href="namespacedepspawn.html#a7eb50aaa5c50b092a1afead977471347" title="Traits for arguments or parameters that should be ignored. ">ignore()</a></code> and <code><a class="el" href="classdepspawn_1_1_ignore.html" title="Class for ignoring arguments when doing dependency analysis. ">Ignore</a></code> are a function and a class, respectively, that help express situations in which we do not want to track dependencies on a given task argument. They are discussed in <a class="el" href="page_trickstips.html#sec_ignore">A general mechanism to avoid generating dependencies</a>.</li>
</ul>
<h2><a class="anchor" id="sec_example1"></a>
Example</h2>
<p>The following example illustrates the use of this API to parallelize a program in which the variables <code>i</code> and <code>j</code> can be modified in two parallel <code>incr</code> tasks, while a third task <code>add</code> must wait for them to finish in order to use them to compute <code>r</code>.</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;depspawn/depspawn.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedepspawn.html">depspawn</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> incr(<span class="keywordtype">int</span> &amp;i) {</div><div class="line">  i++;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> add(<span class="keywordtype">int</span> &amp;r, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div><div class="line">  r = a + b;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> i = 0, j = 8, r;</div><div class="line">  </div><div class="line">  <a class="code" href="namespacedepspawn.html#a0567a4e61daab69185cbf9bf5a814d8e">set_threads</a>();</div><div class="line"></div><div class="line">  <a class="code" href="namespacedepspawn.html#aad6ae0fb6423de998a3418ac3b52aef9">spawn</a>(incr, i);</div><div class="line">  <a class="code" href="namespacedepspawn.html#aad6ae0fb6423de998a3418ac3b52aef9">spawn</a>(incr, j);</div><div class="line">  <a class="code" href="namespacedepspawn.html#aad6ae0fb6423de998a3418ac3b52aef9">spawn</a>(add, r, i, j);</div><div class="line">  </div><div class="line">  <a class="code" href="namespacedepspawn.html#a61d360457bcbd1f029f1689d36f9c2e1">wait_for_all</a>();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Result=&quot;</span> &lt;&lt; r &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> test_ok = (r == 10);</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;TEST &quot;</span> &lt;&lt; (test_ok ? <span class="stringliteral">&quot;SUCCESSFUL&quot;</span> : <span class="stringliteral">&quot;UNSUCCESSFUL&quot;</span>) &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> !test_ok;</div><div class="line">}</div></div><!-- fragment --> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Dec 15 2017 18:53:05 for DepSpawn by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
