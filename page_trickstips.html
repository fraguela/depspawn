<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>DepSpawn: Tips &amp; tricks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DepSpawn
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_trickstips.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tips &amp; tricks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec_stdmove">Freezing arguments</a></li>
<li class="level1"><a href="#sec_pointertrick">Using pointers to avoid generating false dependencies</a></li>
<li class="level1"><a href="#sec_ignore">A general mechanism to avoid generating dependencies</a></li>
<li class="level1"><a href="#sec_sequential">Sequential execution</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="sec_stdmove"></a>
Freezing arguments</h1>
<p>Sometimes one may need to freeze an argument to a task, so that it is not affected by future changes of the value of the object. A typical example of this situation would be the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(i = 0; i &lt; N; i++)</div>
<div class="line">  <a class="code" href="namespacedepspawn.html#ac3ceb77e54accb72e8483e146ebba8f3">spawn</a>(f, w, i);</div>
</div><!-- fragment --><p> in which we want each task to work with a different value of <code>i</code>. Unfortunately, <code>i</code> is being modified in each iteration of the loop, so when the task generated during a given iteration x begins its execution, it will probably find that <code>i</code> has no longer the value x.</p>
<p>Another situation in which we would need to freeze an argument is when it may have already destroyed when the task begins its execution. Let us have a look for example to this code: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_function(Widget &amp;w) {</div>
<div class="line">   <span class="keywordtype">int</span> i = w.something();</div>
<div class="line">   <a class="code" href="namespacedepspawn.html#ac3ceb77e54accb72e8483e146ebba8f3">spawn</a>(f, w, i);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">my_function(my_widget);</div>
</div><!-- fragment --><p> Do you see the problem? <code>f</code> will try to access <code>i</code> as one of its arguments when it begins its execution, but at that point very probably the thread that spawed the task will have already left function <code>my_function</code>, thus destroying <code>i</code>.</p>
<p>Fortunately, freezing an argument to a spawned task is very easy: it suffices to turn it into an rvalue by means of the <code>std::move</code> function found in the <code>&lt;utility&gt;</code> standard header. Thus, the correct coding for our examples would be <code>spawn(f, w, std::move(i))</code> in both of them.</p>
<p>Notice that freezing an argument has a secondary effect: since the task works with a frozen copy of the variable, it does not have to track dependencies on that argument and it does not generate new dependencies for subsequent tasks that use the frozen variable either. Also, since the task receives a copy, any change will be made on the copy, so even if the corresponding argument is a non-<code>const</code> reference, those changes will not be reflected in the original variable.</p>
<h1><a class="anchor" id="sec_pointertrick"></a>
Using pointers to avoid generating false dependencies</h1>
<p>The requirement that a task must fulfill all the dependencies on its arguments before it can begin its execution always leads to correct executions, but sometimes it can limit the performance unnecessarily. Imagine we have this piece of code </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> does_more_stuff(Widget &amp;w) {</div>
<div class="line">   .... <span class="comment">// Part 1: does not use w</span></div>
<div class="line">   <a class="code" href="namespacedepspawn.html#ac3ceb77e54accb72e8483e146ebba8f3">spawn</a>(works_on_widget, w, other_stuff);</div>
<div class="line">   ...  <span class="comment">// Part 2: can be done in parallel with works_on_widget</span></div>
<div class="line">   <a class="code" href="namespacedepspawn.html#a37ce8e8e49fec2796d703d0cffb15d72">wait_for</a>(w);</div>
<div class="line">   ...  <span class="comment">// Part 3: do something with w</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacedepspawn.html#ac3ceb77e54accb72e8483e146ebba8f3">spawn</a>(f, ..., my_widget, ...);</div>
<div class="line"><a class="code" href="namespacedepspawn.html#ac3ceb77e54accb72e8483e146ebba8f3">spawn</a>(does_more_stuff, my_widget);</div>
</div><!-- fragment --><p> where <code>works_on_widget</code> modifies its first argument. Since <code>does_more_stuff</code> receives its argument by means of a non-<code>const</code> reference, it will only begin its execution once <code>f</code> finishes, as there is a dependency on <code>my_widget</code>. While this is correct, we can see that <code>does_more_stuff</code> does not actually interact with <code>w</code> until Part 3 . Thus we could actually parallelize the execution of <code>f</code> with Parts 1 and 2 of <code>does_more_stuff</code> if we could pass to <code>does_more_stuff</code> its argument in such a way that this dependency were not seen. This could be achieved using what we learned on pointers in <a class="el" href="page_basics.html#sec_dependencies">Express dependencies by means of the parameter types</a>, which is basically that a pointer carries dependences on the pointer itself, but not on the object(s) it points to. As a result, if we wrote our code like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> does_more_stuff(Widget *wp) {</div>
<div class="line">   Widget&amp; w = *wp;</div>
<div class="line">   .... <span class="comment">// Part 1: does not use w</span></div>
<div class="line">   <a class="code" href="namespacedepspawn.html#ac3ceb77e54accb72e8483e146ebba8f3">spawn</a>(works_on_widget, w, other_stuff);</div>
<div class="line">   ...  <span class="comment">// Part 2: can be done in parallel with works_on_widget</span></div>
<div class="line">   <a class="code" href="namespacedepspawn.html#a37ce8e8e49fec2796d703d0cffb15d72">wait_for</a>(w);</div>
<div class="line">   ...  <span class="comment">// Part 3: do something with w</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacedepspawn.html#ac3ceb77e54accb72e8483e146ebba8f3">spawn</a>(f, ..., my_widget, ...);</div>
<div class="line"><a class="code" href="namespacedepspawn.html#ac3ceb77e54accb72e8483e146ebba8f3">spawn</a>(does_more_stuff, &amp;my_widget);</div>
</div><!-- fragment --><p> DepSpawn would not see any dependency between <code>f</code> and <code>does_more_stuff</code> and it would run them in parallel. The dependencies on <code>works_on_widget</code> and the <code>wait_for</code> statement would be honored, as they are expressed on the object itself, not on a pointer to it.</p>
<h1><a class="anchor" id="sec_ignore"></a>
A general mechanism to avoid generating dependencies</h1>
<p>The pointer pointer trick requires changing both the API and the invocation of a function, which may be sometimes undesirable. Also, it changes permanently the semantics of the associated function parameter, while it may be the case that we only want to avoid dependencies in some specific invocation(s) of a function. For this reason, DepSpawn provides two other mechanisms to avoid generating dependencies:</p><ul>
<li><code><a class="el" href="namespacedepspawn.html#a7eb50aaa5c50b092a1afead977471347" title="Traits for arguments or parameters that should be ignored. ">ignore()</a></code> is a function such that if an argument <code>x</code> to a <code><a class="el" href="namespacedepspawn.html#ac3ceb77e54accb72e8483e146ebba8f3" title="Spawns a std::function. ">spawn()</a></code> invocation is written like <code>ignore(x)</code>, any dependency on <code>x</code> will be ignored for the sake of this task. This means that, just as with the pointer trick, it will neither wait for pending writes or reads to <code>x</code> nor generate new dependencies for future tasks that could access <code>x</code>.</li>
<li>If a format parameter of a function <code>f</code> that used to have type <code>T</code> is changed to have type <code><a class="el" href="classdepspawn_1_1_ignore.html" title="Class for ignoring arguments when doing dependency analysis. ">Ignore</a>&lt;T&gt;</code>, similarly to what happened with the pointer trick, it will never track or generate dependencies on the argument provided for that parameter. The advantage here is that, contrary to the pointer trick, we can continue to send the argument "as is" to <code>f</code> instead of its address. <code><a class="el" href="classdepspawn_1_1_ignore.html" title="Class for ignoring arguments when doing dependency analysis. ">Ignore</a>&lt;T&gt;</code> provides an implicit conversion operator to the type <code>T</code> to access its content.</li>
</ul>
<h1><a class="anchor" id="sec_sequential"></a>
Sequential execution</h1>
<p>If the macro <code>SEQUENTIAL_DEPSPAWN</code> is defined during the compilation of a source file, its <code><a class="el" href="namespacedepspawn.html#ac3ceb77e54accb72e8483e146ebba8f3" title="Spawns a std::function. ">spawn()</a></code> operations will be replaced by sequential function invocations. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 20 2016 17:35:40 for DepSpawn by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
